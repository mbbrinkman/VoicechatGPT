<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Voice Chat">
    <title>OpenAI Realtime Voice Chat</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #667eea;
            --primary-dark: #764ba2;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --bg-glass: rgba(255,255,255,0.1);
            --bg-glass-solid: rgba(255,255,255,0.15);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: #fff;
            min-height: 100vh;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        .container {
            max-width: 480px;
            margin: 0 auto;
            padding: 20px;
            padding-bottom: 80px;
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            background: var(--bg-glass);
            padding: 5px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }

        .tab {
            flex: 1;
            padding: 12px;
            border: none;
            background: transparent;
            color: rgba(255,255,255,0.7);
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s;
        }

        .tab.active {
            background: rgba(255,255,255,0.2);
            color: #fff;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Status */
        .status {
            background: var(--bg-glass);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s ease-in-out infinite;
        }

        .status-indicator.disconnected { background: var(--danger); }
        .status-indicator.connecting { background: var(--warning); }
        .status-indicator.connected { background: var(--success); }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Controls */
        .control-group {
            background: var(--bg-glass);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            backdrop-filter: blur(10px);
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 14px;
        }

        input, select, textarea {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            background: rgba(255,255,255,0.9);
            color: #333;
            font-size: 16px;
            font-family: inherit;
        }

        textarea {
            resize: vertical;
            min-height: 80px;
        }

        .info-text {
            font-size: 12px;
            opacity: 0.8;
            margin-top: 5px;
            line-height: 1.4;
        }

        /* Buttons */
        button {
            width: 100%;
            padding: 15px 20px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            background: var(--bg-glass-solid);
            color: #fff;
            backdrop-filter: blur(10px);
            touch-action: manipulation;
        }

        button:active {
            transform: scale(0.95);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary { background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%); }
        .btn-success { background: linear-gradient(135deg, #10b981 0%, #059669 100%); }
        .btn-danger { background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); }
        .btn-warning { background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); }

        .button-row {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .button-row button {
            flex: 1;
        }

        /* Push to Talk */
        .ptt-button {
            height: 100px;
            font-size: 20px;
            margin: 20px 0;
        }

        .ptt-button.active {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            box-shadow: 0 0 30px rgba(239, 68, 68, 0.8);
        }

        /* Settings Sections */
        .settings-section {
            margin-bottom: 20px;
        }

        .settings-section h3 {
            margin-bottom: 15px;
            font-size: 16px;
            color: #fbbf24;
        }

        .setting-item {
            margin-bottom: 15px;
        }

        .setting-item label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
            opacity: 0.9;
        }

        /* Range Inputs */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255,255,255,0.3);
            height: 6px;
            border-radius: 3px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            border: none;
        }

        .range-value {
            display: inline-block;
            margin-left: 10px;
            font-weight: 600;
            color: #fbbf24;
        }

        /* Checkbox */
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .checkbox-item input[type="checkbox"] {
            width: auto;
            height: 20px;
            accent-color: var(--primary);
        }

        .checkbox-item label {
            margin: 0 !important;
        }

        /* Video */
        .video-container {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 20px;
            position: relative;
            display: none;
        }

        .video-container.active {
            display: block;
        }

        video {
            width: 100%;
            display: block;
        }

        .video-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 10px;
            background: linear-gradient(to top, rgba(0,0,0,0.7), transparent);
            display: flex;
            gap: 10px;
        }

        .video-controls button {
            padding: 8px;
            font-size: 14px;
        }

        /* Collapsible sections */
        .collapsible-header {
            background: var(--bg-glass-solid);
            padding: 12px 15px;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .collapsible-header:hover {
            background: rgba(255,255,255,0.2);
        }

        .collapsible-content {
            display: none;
            padding-bottom: 10px;
        }

        .collapsible-content.open {
            display: block;
        }

        .collapse-icon {
            transition: transform 0.3s;
        }

        .collapse-icon.open {
            transform: rotate(180deg);
        }

        @media (max-width: 400px) {
            .container { padding: 15px; padding-bottom: 80px; }
            h1 { font-size: 20px; }
            button { padding: 12px 15px; font-size: 14px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>OpenAI Realtime Voice Chat</h1>

        <div class="status">
            <span class="status-indicator disconnected" id="statusIndicator"></span>
            <span id="statusText">Disconnected</span>
        </div>

        <!-- Tabs -->
        <div class="tabs">
            <button class="tab active" onclick="switchTab('chat')">Chat</button>
            <button class="tab" onclick="switchTab('settings')">Settings</button>
        </div>

        <!-- Chat Tab -->
        <div class="tab-content active" id="chatTab">
            <div class="control-group">
                <label for="apiKey">OpenAI API Key</label>
                <input type="password" id="apiKey" placeholder="sk-...">
                <div class="info-text">
                    Stored locally. For production, use ephemeral tokens from your server.
                </div>
            </div>

            <div class="button-row">
                <button onclick="connect()" class="btn-success" id="connectBtn">Connect</button>
                <button onclick="disconnect()" class="btn-danger" id="disconnectBtn" disabled>Disconnect</button>
            </div>

            <button class="ptt-button btn-warning" id="pttButton" disabled
                    onmousedown="startPushToTalk()"
                    onmouseup="stopPushToTalk()"
                    ontouchstart="startPushToTalk(event)"
                    ontouchend="stopPushToTalk(event)">
                Hold to Talk
            </button>

            <div class="button-row">
                <button onclick="interruptResponse()" class="btn-danger" id="interruptBtn" disabled>Interrupt</button>
            </div>

            <div class="button-row">
                <button onclick="startCamera()" class="btn-primary" id="cameraBtn">Camera</button>
                <button onclick="startScreenShare()" class="btn-primary" id="screenBtn">Screen</button>
            </div>

            <div class="video-container" id="videoContainer">
                <video id="localVideo" autoplay playsinline muted></video>
                <div class="video-controls">
                    <button onclick="stopVideo()" class="btn-danger">Stop Video</button>
                </div>
            </div>
        </div>

        <!-- Settings Tab -->
        <div class="tab-content" id="settingsTab">
            <!-- Model Settings -->
            <div class="settings-section">
                <div class="control-group">
                    <label for="model">Model</label>
                    <select id="model">
                        <option value="gpt-realtime" selected>gpt-realtime (Latest - Aug 2025)</option>
                        <option value="gpt-4o-realtime-preview-2025-06-03">gpt-4o-realtime-preview-2025-06-03</option>
                        <option value="gpt-4o-mini-realtime-preview-2024-12-17">gpt-4o-mini-realtime-preview (2024-12-17)</option>
                        <option value="gpt-4o-realtime-preview-2024-12-17">gpt-4o-realtime-preview (2024-12-17)</option>
                        <option value="gpt-4o-realtime-preview">gpt-4o-realtime-preview (Generic)</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="voice">Voice</label>
                    <select id="voice">
                        <option value="alloy">Alloy (Neutral, balanced)</option>
                        <option value="ash">Ash (Clear, precise)</option>
                        <option value="ballad">Ballad (Melodic, smooth)</option>
                        <option value="coral">Coral (Warm, friendly)</option>
                        <option value="echo">Echo (Resonant, deep)</option>
                        <option value="sage">Sage (Calm, thoughtful)</option>
                        <option value="shimmer" selected>Shimmer (Bright, energetic)</option>
                        <option value="verse">Verse (Versatile, expressive)</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="instructions">System Instructions</label>
                    <textarea id="instructions" placeholder="You are a helpful assistant...">You are a helpful assistant. Be concise and friendly.</textarea>
                </div>
            </div>

            <!-- Modalities -->
            <div class="collapsible-header" onclick="toggleCollapsible('modalities')">
                <span>Modalities</span>
                <span class="collapse-icon" id="modalities-icon">â–¼</span>
            </div>
            <div class="collapsible-content" id="modalities-content">
                <div class="control-group">
                    <div class="checkbox-item">
                        <input type="checkbox" id="modalityText" checked>
                        <label for="modalityText">Text</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="modalityAudio" checked>
                        <label for="modalityAudio">Audio</label>
                    </div>
                </div>
            </div>

            <!-- Audio Formats -->
            <div class="collapsible-header" onclick="toggleCollapsible('audio')">
                <span>Audio Formats</span>
                <span class="collapse-icon" id="audio-icon">â–¼</span>
            </div>
            <div class="collapsible-content" id="audio-content">
                <div class="control-group">
                    <label for="inputAudioFormat">Input Audio Format</label>
                    <select id="inputAudioFormat">
                        <option value="pcm16" selected>PCM16 (24kHz, 16-bit)</option>
                        <option value="g711_ulaw">G.711 Î¼-law</option>
                        <option value="g711_alaw">G.711 A-law</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="outputAudioFormat">Output Audio Format</label>
                    <select id="outputAudioFormat">
                        <option value="pcm16" selected>PCM16 (24kHz, 16-bit)</option>
                        <option value="g711_ulaw">G.711 Î¼-law</option>
                        <option value="g711_alaw">G.711 A-law</option>
                    </select>
                </div>
            </div>

            <!-- Turn Detection -->
            <div class="collapsible-header" onclick="toggleCollapsible('turndet')">
                <span>Turn Detection</span>
                <span class="collapse-icon" id="turndet-icon">â–¼</span>
            </div>
            <div class="collapsible-content" id="turndet-content">
                <div class="control-group">
                    <label for="turnDetectionType">Type</label>
                    <select id="turnDetectionType" onchange="updateTurnDetectionUI()">
                        <option value="server_vad" selected>Server VAD</option>
                        <option value="semantic_vad">Semantic VAD</option>
                        <option value="none">None (Manual)</option>
                    </select>

                    <!-- Server VAD Settings -->
                    <div id="serverVadSettings">
                        <div class="setting-item">
                            <label>Threshold: <span class="range-value" id="vadThresholdValue">0.5</span></label>
                            <input type="range" id="vadThreshold" min="0" max="1" step="0.05" value="0.5">
                            <div class="info-text">Speech detection sensitivity (0.0-1.0)</div>
                        </div>

                        <div class="setting-item">
                            <label>Prefix Padding: <span class="range-value" id="prefixPaddingMsValue">300</span>ms</label>
                            <input type="range" id="prefixPaddingMs" min="0" max="1000" step="50" value="300">
                            <div class="info-text">Audio before speech detection</div>
                        </div>

                        <div class="setting-item">
                            <label>Silence Duration: <span class="range-value" id="silenceDurationMsValue">800</span>ms</label>
                            <input type="range" id="silenceDurationMs" min="100" max="3000" step="100" value="800">
                            <div class="info-text">Silence before turn ends</div>
                        </div>
                    </div>

                    <!-- Semantic VAD Settings -->
                    <div id="semanticVadSettings" style="display: none;">
                        <div class="setting-item">
                            <label for="eagerness">Eagerness</label>
                            <select id="eagerness">
                                <option value="auto" selected>Auto</option>
                                <option value="low">Low</option>
                                <option value="medium">Medium</option>
                                <option value="high">High</option>
                            </select>
                            <div class="info-text">How eagerly the model detects turn completion</div>
                        </div>

                        <div class="checkbox-item">
                            <input type="checkbox" id="createResponse" checked>
                            <label for="createResponse">Auto-create Response</label>
                        </div>

                        <div class="checkbox-item">
                            <input type="checkbox" id="interruptResponse" checked>
                            <label for="interruptResponse">Allow Interrupt Response</label>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Noise Reduction -->
            <div class="collapsible-header" onclick="toggleCollapsible('noise')">
                <span>Input Audio Noise Reduction</span>
                <span class="collapse-icon" id="noise-icon">â–¼</span>
            </div>
            <div class="collapsible-content" id="noise-content">
                <div class="control-group">
                    <div class="checkbox-item">
                        <input type="checkbox" id="enableNoiseReduction">
                        <label for="enableNoiseReduction">Enable Noise Reduction</label>
                    </div>

                    <div id="noiseReductionSettings" style="display: none;">
                        <label for="noiseReductionType">Mode</label>
                        <select id="noiseReductionType">
                            <option value="near_field" selected>Near Field (headset/close mic)</option>
                            <option value="far_field">Far Field (laptop/room mic)</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- Response Generation -->
            <div class="collapsible-header" onclick="toggleCollapsible('response')">
                <span>Response Generation</span>
                <span class="collapse-icon" id="response-icon">â–¼</span>
            </div>
            <div class="collapsible-content" id="response-content">
                <div class="control-group">
                    <div class="setting-item">
                        <label>Temperature: <span class="range-value" id="temperatureValue">0.8</span></label>
                        <input type="range" id="temperature" min="0.6" max="1.2" step="0.05" value="0.8">
                        <div class="info-text">Randomness (0.6-1.2, recommended: 0.8)</div>
                    </div>

                    <div class="setting-item">
                        <label>Max Response Tokens: <span class="range-value" id="maxResponseTokensValue">4096</span></label>
                        <input type="range" id="maxResponseTokens" min="256" max="4096" step="256" value="4096">
                        <div class="info-text">Maximum output length</div>
                    </div>
                </div>
            </div>

            <!-- Input Audio Transcription -->
            <div class="collapsible-header" onclick="toggleCollapsible('transcription')">
                <span>Input Audio Transcription</span>
                <span class="collapse-icon" id="transcription-icon">â–¼</span>
            </div>
            <div class="collapsible-content" id="transcription-content">
                <div class="control-group">
                    <div class="checkbox-item">
                        <input type="checkbox" id="enableTranscription">
                        <label for="enableTranscription">Enable Transcription</label>
                    </div>

                    <div id="transcriptionSettings" style="display: none;">
                        <div class="setting-item">
                            <label for="transcriptionModel">Model</label>
                            <input type="text" id="transcriptionModel" value="whisper-1">
                        </div>
                    </div>
                </div>
            </div>

            <!-- Tools -->
            <div class="collapsible-header" onclick="toggleCollapsible('tools')">
                <span>Tools & Function Calling</span>
                <span class="collapse-icon" id="tools-icon">â–¼</span>
            </div>
            <div class="collapsible-content" id="tools-content">
                <div class="control-group">
                    <label for="toolChoice">Tool Choice</label>
                    <select id="toolChoice">
                        <option value="auto" selected>Auto</option>
                        <option value="none">None</option>
                        <option value="required">Required</option>
                    </select>
                    <div class="info-text">No tools configured yet. Add via session.update.</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let ws = null;
        let audioContext = null;
        let audioStream = null;
        let mediaRecorder = null;
        let isRecording = false;
        let isPushToTalkActive = false;
        let mediaStream = null;
        let audioQueue = [];
        let isPlaying = false;
        let currentAudioSource = null;
        let audioContextUnlocked = false;
        let audioProcessor = null;
        let audioSource = null;

        // DOM elements
        const apiKeyInput = document.getElementById('apiKey');
        const statusIndicator = document.getElementById('statusIndicator');
        const statusText = document.getElementById('statusText');
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const pttButton = document.getElementById('pttButton');
        const interruptBtn = document.getElementById('interruptBtn');
        const videoContainer = document.getElementById('videoContainer');
        const localVideo = document.getElementById('localVideo');

        // Load API key
        window.addEventListener('load', () => {
            const savedKey = localStorage.getItem('openai_api_key');
            if (savedKey) apiKeyInput.value = savedKey;

            setupRangeInputs();
            setupCheckboxListeners();

            document.addEventListener('touchstart', unlockAudioContext, { once: true });
            document.addEventListener('click', unlockAudioContext, { once: true });
        });

        apiKeyInput.addEventListener('change', () => {
            localStorage.setItem('openai_api_key', apiKeyInput.value);
        });

        function unlockAudioContext() {
            if (!audioContextUnlocked && audioContext) {
                const buffer = audioContext.createBuffer(1, 1, 22050);
                const source = audioContext.createBufferSource();
                source.buffer = buffer;
                source.connect(audioContext.destination);
                source.start(0);
                audioContextUnlocked = true;
                console.log('ðŸ”“ Audio context unlocked');
            }
        }

        function switchTab(tab) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

            if (tab === 'chat') {
                document.querySelectorAll('.tab')[0].classList.add('active');
                document.getElementById('chatTab').classList.add('active');
            } else {
                document.querySelectorAll('.tab')[1].classList.add('active');
                document.getElementById('settingsTab').classList.add('active');
            }
        }

        function toggleCollapsible(id) {
            const content = document.getElementById(id + '-content');
            const icon = document.getElementById(id + '-icon');
            content.classList.toggle('open');
            icon.classList.toggle('open');
        }

        function setupRangeInputs() {
            const ranges = [
                'vadThreshold', 'prefixPaddingMs', 'silenceDurationMs',
                'temperature', 'maxResponseTokens'
            ];

            ranges.forEach(id => {
                const input = document.getElementById(id);
                const valueSpan = document.getElementById(id + 'Value');
                if (input && valueSpan) {
                    input.addEventListener('input', () => {
                        valueSpan.textContent = input.value;
                    });
                }
            });
        }

        function setupCheckboxListeners() {
            document.getElementById('enableNoiseReduction').addEventListener('change', (e) => {
                document.getElementById('noiseReductionSettings').style.display =
                    e.target.checked ? 'block' : 'none';
            });

            document.getElementById('enableTranscription').addEventListener('change', (e) => {
                document.getElementById('transcriptionSettings').style.display =
                    e.target.checked ? 'block' : 'none';
            });
        }

        function updateTurnDetectionUI() {
            const type = document.getElementById('turnDetectionType').value;
            document.getElementById('serverVadSettings').style.display =
                type === 'server_vad' ? 'block' : 'none';
            document.getElementById('semanticVadSettings').style.display =
                type === 'semantic_vad' ? 'block' : 'none';
        }

        function updateStatus(status, text) {
            statusIndicator.className = `status-indicator ${status}`;
            statusText.textContent = text;
        }

        function getSessionConfig() {
            const modalities = [];
            if (document.getElementById('modalityText').checked) modalities.push('text');
            if (document.getElementById('modalityAudio').checked) modalities.push('audio');

            const config = {
                modalities: modalities,
                instructions: document.getElementById('instructions').value,
                voice: document.getElementById('voice').value,
                input_audio_format: document.getElementById('inputAudioFormat').value,
                output_audio_format: document.getElementById('outputAudioFormat').value,
                temperature: parseFloat(document.getElementById('temperature').value),
                max_response_output_tokens: parseInt(document.getElementById('maxResponseTokens').value),
                tool_choice: document.getElementById('toolChoice').value
            };

            // Turn detection
            const turnDetectionType = document.getElementById('turnDetectionType').value;
            if (turnDetectionType === 'server_vad') {
                config.turn_detection = {
                    type: 'server_vad',
                    threshold: parseFloat(document.getElementById('vadThreshold').value),
                    prefix_padding_ms: parseInt(document.getElementById('prefixPaddingMs').value),
                    silence_duration_ms: parseInt(document.getElementById('silenceDurationMs').value)
                };
            } else if (turnDetectionType === 'semantic_vad') {
                config.turn_detection = {
                    type: 'semantic_vad',
                    eagerness: document.getElementById('eagerness').value,
                    create_response: document.getElementById('createResponse').checked,
                    interrupt_response: document.getElementById('interruptResponse').checked
                };
            } else {
                config.turn_detection = null;
            }

            // Noise reduction
            if (document.getElementById('enableNoiseReduction').checked) {
                config.input_audio_noise_reduction = {
                    type: document.getElementById('noiseReductionType').value
                };
            }

            // Transcription
            if (document.getElementById('enableTranscription').checked) {
                config.input_audio_transcription = {
                    model: document.getElementById('transcriptionModel').value
                };
            }

            return config;
        }

        async function connect() {
            const apiKey = apiKeyInput.value.trim();
            if (!apiKey) {
                alert('Please enter your OpenAI API key');
                return;
            }

            try {
                updateStatus('connecting', 'Connecting...');
                connectBtn.disabled = true;

                // Initialize audio context
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 24000,
                        latencyHint: 'interactive'
                    });
                }

                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }

                // Get microphone
                audioStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        channelCount: 1,
                        sampleRate: 24000,
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });

                // Connect WebSocket
                const model = document.getElementById('model').value;
                const wsUrl = `wss://api.openai.com/v1/realtime?model=${model}`;
                const protocols = ["realtime", `openai-insecure-api-key.${apiKey}`, "openai-beta.realtime-v1"];

                ws = new WebSocket(wsUrl, protocols);

                ws.onopen = () => {
                    console.log('âœ… WebSocket connected');

                    const sessionConfig = getSessionConfig();
                    console.log('ðŸ“¤ Session config:', sessionConfig);

                    ws.send(JSON.stringify({
                        type: 'session.update',
                        session: sessionConfig
                    }));

                    updateStatus('connected', 'Connected');
                    connectBtn.disabled = true;
                    disconnectBtn.disabled = false;
                    pttButton.disabled = false;
                    interruptBtn.disabled = false;

                    // Auto-start recording if VAD enabled
                    if (document.getElementById('turnDetectionType').value !== 'none') {
                        startContinuousRecording();
                    }
                };

                ws.onmessage = async (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        console.log('ðŸ“¨', message.type);

                        switch (message.type) {
                            case 'session.created':
                            case 'session.updated':
                                console.log('âœ… Session:', message.session);
                                break;

                            case 'response.audio.delta':
                                if (message.delta) await playAudioDelta(message.delta);
                                break;

                            case 'input_audio_buffer.speech_started':
                                statusText.textContent = 'Listening...';
                                break;

                            case 'input_audio_buffer.speech_stopped':
                                statusText.textContent = 'Processing...';
                                break;

                            case 'conversation.item.input_audio_transcription.completed':
                                console.log('ðŸ“ You:', message.transcript);
                                break;

                            case 'response.audio_transcript.done':
                                console.log('ðŸ“ Assistant:', message.transcript);
                                break;

                            case 'response.text.done':
                                console.log('ðŸ“ Assistant text:', message.text);
                                break;

                            case 'response.created':
                                statusText.textContent = 'Responding...';
                                break;

                            case 'response.done':
                                statusText.textContent = 'Connected';
                                break;

                            case 'error':
                                console.error('âŒ Error:', message.error);
                                statusText.textContent = `Error: ${message.error.type}`;

                                let errorMsg = message.error.message || 'Unknown error';
                                if (message.error.code === 'invalid_api_key') {
                                    errorMsg = 'Invalid API key';
                                } else if (message.error.code === 'insufficient_quota') {
                                    errorMsg = 'Insufficient quota';
                                }
                                alert(`Error: ${errorMsg}`);
                                break;
                        }
                    } catch (error) {
                        console.error('âŒ Parse error:', error);
                    }
                };

                ws.onerror = (error) => {
                    console.error('âŒ WebSocket error:', error);
                    updateStatus('disconnected', 'Connection error');
                };

                ws.onclose = () => {
                    console.log('WebSocket closed');
                    disconnect();
                };

            } catch (error) {
                console.error('âŒ Connection failed:', error);
                alert(`Failed: ${error.message}`);
                updateStatus('disconnected', 'Failed');
                connectBtn.disabled = false;
            }
        }

        function disconnect() {
            if (ws) {
                ws.close();
                ws = null;
            }

            if (audioProcessor) {
                audioProcessor.disconnect();
                audioProcessor = null;
            }

            if (audioSource) {
                audioSource.disconnect();
                audioSource = null;
            }

            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
                audioStream = null;
            }

            updateStatus('disconnected', 'Disconnected');
            connectBtn.disabled = false;
            disconnectBtn.disabled = true;
            pttButton.disabled = true;
            interruptBtn.disabled = true;
            isRecording = false;
        }

        async function startContinuousRecording() {
            if (!audioStream || isRecording) return;

            try {
                audioSource = audioContext.createMediaStreamSource(audioStream);
                audioProcessor = audioContext.createScriptProcessor(2048, 1, 1);

                audioProcessor.onaudioprocess = (e) => {
                    if (!ws || ws.readyState !== WebSocket.OPEN) return;

                    const inputData = e.inputBuffer.getChannelData(0);
                    const pcm16 = floatTo16BitPCM(inputData);
                    const base64Audio = arrayBufferToBase64(pcm16);

                    try {
                        ws.send(JSON.stringify({
                            type: 'input_audio_buffer.append',
                            audio: base64Audio
                        }));
                    } catch (error) {
                        console.error('âŒ Send error:', error);
                    }
                };

                audioSource.connect(audioProcessor);
                audioProcessor.connect(audioContext.destination);
                isRecording = true;

                console.log('âœ… Recording started');
            } catch (error) {
                console.error('âŒ Recording error:', error);
                alert('Failed to start recording: ' + error.message);
            }
        }

        function startPushToTalk(event) {
            if (event) event.preventDefault();
            if (!ws || ws.readyState !== WebSocket.OPEN || isPushToTalkActive) return;

            isPushToTalkActive = true;
            pttButton.classList.add('active');
            pttButton.textContent = 'Recording...';

            ws.send(JSON.stringify({ type: 'input_audio_buffer.clear' }));
            startContinuousRecording();
        }

        function stopPushToTalk(event) {
            if (event) event.preventDefault();
            if (!isPushToTalkActive) return;

            isPushToTalkActive = false;
            pttButton.classList.remove('active');
            pttButton.textContent = 'Hold to Talk';

            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'input_audio_buffer.commit' }));
                ws.send(JSON.stringify({ type: 'response.create' }));
            }
        }

        function interruptResponse() {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;

            if (currentAudioSource) {
                currentAudioSource.stop();
                currentAudioSource = null;
            }
            audioQueue = [];
            isPlaying = false;

            ws.send(JSON.stringify({ type: 'response.cancel' }));
            ws.send(JSON.stringify({ type: 'input_audio_buffer.clear' }));

            console.log('â¹ï¸ Interrupted');
        }

        async function playAudioDelta(base64Audio) {
            try {
                const audioData = base64ToArrayBuffer(base64Audio);
                const float32Data = pcm16ToFloat32(new Int16Array(audioData));

                const audioBuffer = audioContext.createBuffer(1, float32Data.length, 24000);
                audioBuffer.getChannelData(0).set(float32Data);

                audioQueue.push(audioBuffer);

                if (!isPlaying) playNextInQueue();
            } catch (error) {
                console.error('âŒ Audio playback error:', error);
            }
        }

        function playNextInQueue() {
            if (audioQueue.length === 0) {
                isPlaying = false;
                return;
            }

            isPlaying = true;
            const audioBuffer = audioQueue.shift();

            const source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(audioContext.destination);

            source.onended = () => {
                currentAudioSource = null;
                playNextInQueue();
            };

            currentAudioSource = source;
            source.start(0);
        }

        // Audio conversion utilities
        function floatTo16BitPCM(float32Array) {
            const buffer = new ArrayBuffer(float32Array.length * 2);
            const view = new DataView(buffer);
            let offset = 0;

            for (let i = 0; i < float32Array.length; i++, offset += 2) {
                const s = Math.max(-1, Math.min(1, float32Array[i]));
                view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
            }

            return buffer;
        }

        function pcm16ToFloat32(int16Array) {
            const float32Array = new Float32Array(int16Array.length);
            for (let i = 0; i < int16Array.length; i++) {
                float32Array[i] = int16Array[i] / (int16Array[i] < 0 ? 0x8000 : 0x7FFF);
            }
            return float32Array;
        }

        function arrayBufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = '';
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        function base64ToArrayBuffer(base64) {
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes.buffer;
        }

        // Video/Screen sharing
        async function startCamera() {
            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: 1280, height: 720 },
                    audio: false
                });
                localVideo.srcObject = mediaStream;
                videoContainer.classList.add('active');
            } catch (error) {
                console.error('âŒ Camera error:', error);
                alert('Failed to access camera: ' + error.message);
            }
        }

        async function startScreenShare() {
            try {
                mediaStream = await navigator.mediaDevices.getDisplayMedia({
                    video: { width: 1920, height: 1080 },
                    audio: false
                });
                localVideo.srcObject = mediaStream;
                videoContainer.classList.add('active');

                mediaStream.getVideoTracks()[0].onended = () => stopVideo();
            } catch (error) {
                console.error('âŒ Screen share error:', error);
                alert('Failed to share screen: ' + error.message);
            }
        }

        function stopVideo() {
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
            }
            localVideo.srcObject = null;
            videoContainer.classList.remove('active');
        }

        // iOS background audio support
        if ('mediaSession' in navigator) {
            navigator.mediaSession.metadata = new MediaMetadata({
                title: 'OpenAI Voice Chat',
                artist: 'Realtime API',
                album: 'Voice Chat',
            });
        }

        // Wake lock
        let wakeLock = null;
        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                    console.log('ðŸ”’ Wake lock acquired');
                }
            } catch (err) {
                console.error('âŒ Wake lock error:', err);
            }
        }

        connectBtn.addEventListener('click', requestWakeLock);

        document.addEventListener('visibilitychange', async () => {
            if (wakeLock !== null && document.visibilityState === 'visible') {
                await requestWakeLock();
            }
        });
    </script>
</body>
</html>
